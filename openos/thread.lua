---@class ThreadAPI The Thread API provides a variation of coroutines for openos. A thread is superior to basic coroutines in many ways and, for many workflows, is easier to work with. An openos thread is an autonomous non-blocking detachable process.
---@field create fun(thread_proc:function,...:any):ThreadHandle Starts a new thread executing the function `thread_proc` and returns its thread handle, see [Thread Handle API](https://ocdoc.cil.li/api:thread#thread_handle_api "api:thread"). This method takes an optional `...` which is passed to `thread_proc`. The runtime of the thread continues autonomously.
---@field waitForAll fun(treads:ThreadHandle[],timeout:number):boolean,string Waits for the array of `threads` to complete. This blocking call can return in `timeout` seconds if provided. Returns success and an error message on failure. A thread is "completed" under multiple conditions, see `t:join()` for details.
---@field waitForAny fun(threads:ThreadHandle[],timout:number):boolean,string Waits for any single thread to complete and is otherwise equivalent to `thread.waitForAll()`
---@field current fun():ThreadHandle Returns the current thread t object. The init process does not represent a thread and nothing is returned from this method if called from the init process and not inside any thread.
local thread = require("thread")

---@class ThreadHandle
---@field resume fun():boolean,string Resumes (or thaws) a suspended thread. Returns success and an error message on failure. A thread begins its life already in a running state and thus basic thread workflows will not ever need to call `t:resume()`. A "running" thread will autonomously continue until it completes. `t:resume()` is only necessary to resume a thread that has been suspended(`t:suspend()`). **Note** that because you are not directly resuming the thread any exceptions thrown from the thread are absorbed by the threading library and not exposed to your process. <br/>-   At this time there is no way to hook in an exception handler for threads but for now `event.onError` is used to print the error message to "/tmp/event.log". Please note that currently the hard interrupt exception is only thrown once, and the behavior of a process with threads when a hard interrupt is thrown is unspecified. At this time, any one of the threads or the parent process may take the exception. These details are not part of the specification for threads and any part of this implementation detail may change later.
---@field suspend fun():boolean,string Suspends (or freezes) a running thread. Returns success and an error message on failure. A "suspended" thread never autonomously wakes up and dies as soon as its parent process (if attached) closes. A suspended thread ignores events. That means any event listeners or timers created inside the thread will not respond to event notifications. Note that threads do not buffer event signals and a suspended thread may miss event signals it was waiting for. For example, if a thread was last waiting on `event.pull("modem_message")` and is "suspended" and a "modem_message" is received by the computer then the thread will miss the event and never know it happened. Please note that if you suspend a thread that is blocked waiting for an event, it is unspecified which event the thread will receive when it is next resumed. <br/>Suspending the current thread causes the thread to immediately yield and does not resume until `t:resume()` is called explicitly elsewhere.
---@field kill fun() Stabby stab! Kills the thread dead. The thread is terminated and will not continue its thread function. Any event registrations it made will die with it. Keep in mind that the core underlying Lua type is a coroutine which is not a preemptive thread. Thus, the thread's stopping points are deterministic, meaning that you can predict exactly where the thread will stop.
---@field status fun():(string|"'running'"|"'suspended'"|"'dead'") Returns the thread status as a string. <br/>-   **"running"** <br/>    A running thread will continue (autonomously reactivating) after yields and blocking calls until its thread function exits. This is the default and initial state of a created thread. A thread remains in the "running" state even when blocked or not active. A running thread can be suspended(`t:suspend()`) or killed (`t:kill()`) but not resumed(`t:resume()`). A running thread will block calls to `t:join()` and block its parent from closing. Unlike a coroutine which appears "suspended" when not executing in this very moment, a thread state remains "running" even when waiting for an event. <br/>-   **"suspended"** <br/>    A suspended thread will remain suspended and never self resume execution of its thread function. A suspended thread is automatically killed when its attached parent closes or when you attempt to `t:join()` it. A suspended thread ignores event signals, and any event registrations made from the context of the thread, or any child threads created therein, also ignore any event signals. A suspended thread's children behave as if suspended even if their status is "running". A suspended thread can be resumed(`t:resume()`) or killed (`t:kill()`) but not suspended(`t:suspend()`). <br/>-   **"dead"** <br/>    A dead thread has completed or aborted its execution or has been terminated. It cannot be resumed(`t:resume()`) nor suspended(`t:suspend()`). A dead thread does not block a parent process from closing. Killing a dead thread is not an error but does nothing.
---@field attach fun(level:number):boolean,string Attaches a thread to a process, conventionally known as a child thread or attached thread. `level` is an optional used to get parent processes, 0 or nil uses the currently running process. When initially created a thread is already attached to the current process. This method returns nil and an error message if `level` refers to a nonexistent process, otherwise it returns truthy. An attached thread blocks its parent process from closing until the thread dies (or is killed, or the parent process aborts).
---@field detach fun():self|nil,string Detaches a thread from its parent if it has one. Returns nil and an error message if no action was taken, otherwise returns self (handy if you want to create and detach a thread in one line). A detached thread will continue to run until the computer is shutdown or rebooted, or the thread dies.
---@field join fun(timeout:number):boolean,string Blocks the caller until `t` is no longer running or (optionally) returns false if `timeout` seconds is reached. After a call to `t:join()` the thread state is "dead". Any of the following circumstances allow `join` to finish and unblock the caller <br/>>-   The thread continues running until it returns from its thread function <br/>-   The thread aborts, or throws an uncaught exception <br/>-   The thread is suspended <br/>-   The thread is killed <br/>    Calling `thread.waitForAll({t})` is functionally equivalent to calling `t:join()`. When a processs is closing it will call `thread.waitForAll` on the group of its child threads if it has any. A child thread blocks its parent thread by the same machanism.
---@class TransformAPI The transforms library is set of utilities for working with indexed tables. It provides highly reusable special iterators that are at the core of `text` and `sh` command parsing.
---@generic I,V,NI,NV
---@field sub fun(tbl:table<I,V>,first:number,last:number|nil):table<I,V> Behaves similarly to `string.sub`. Returns a sub table of `tbl` from `first` to `last`.
---@field first fun(tbl:table<I,V>,predicate:(fun(e:V,i:I,tbl:table<I,V>):boolean,number|nil)|table<I,V>[],first:number|nil,last:number|nil):number,number Returns the first index in `tbl` (between indexes `first` and `last`, inclusively) where `predicate` is satisfied. The 2nd return is also the ending index of the match. General examples will have the same two values returned, i.e. a match of length 1. The `predicate` can (optionally) return a 2nd return value to indicate the size of the match.<br/><br/>In the case that `predicate` is a table, `transforms.first()` returns the starting and ending index of the first matching sub table in `tbl` that matches ANY one of the tables in `predicate`.
---@field partition fun(tbl:table<I,V>,partitioner:(fun(e:V,i:I,tbl:table<I,V>):boolean,number),first:number|nil,last:number|nil):table<I,V>[] Returns a list of sub lists from `tbl`, generated by `partitioner` within the range from `first` to `last`. `partioner` is a `predicate` function, defined above.<br/><bt/>The `index` parameter passed to the `partitioner` will skip ranges, i.e. it will increase by `n` where `n` is the size of the partition.<bt/><br/>The `partitioner` predicate for this method must return the starting AND ending index of satisfied element sets. Again, see the `predicate` info above.
---@field begins fun(tbl:table<I,V>,sub:table<I,V>,first:number|nil,last:number|nil):boolean Returns true if the subset of `tbl` from `first` to `last` fully composes `v` aligned at the first index. Assuming `first` and `last` have been adjusted for negative wrap around, that is to say: <br/>`v[1] == tbl[first + 0]` <br/>`v[2] == tbl[first + 1]` <br/>... <br/>`v[#v] == tbl[first + #v - 1]` <br/>Where `first + #v - 1` is within the bounds of `[first, last]` of `tbl`.
---@field foreach fun(tbl:table<I,V>,adapter:(fun(e:V,i:I,tbl:table<I,V>):NV,NI|nil),first:number|nil,last:number|nil):table<I|NI,NV> Returns an adaptation of each element in `tbl` from `first` to `last`. Any `nil` result of the `adapter` is ignored, and not appended to the result.<br/>The `adapter` follows the `predicate` signature except for the handling of the return values<br/>-   **Adapter Returns**<br/>    The simple case is to return a single value. E.g. `tx.foreach({'a', 'b', 'c'}, string.upper)` would return `{'A', 'B', 'C'}`.<br/>    The adapter can return `nil` to skip a value. E.g. `tx.foreach({'1', 'foobar', '2'}, function(n) return tonumber(n) end)` would return `{1, 2}`.<br/>    But the `adapter` can return a second value that is used in place of the next sequence number. E.g. `tx.foreach({'1','foobar','3'},function(n,i) return tonumber(n), tostring(i) end)` would return `{["1"]=1, ["3"]=3}`
local transform = require("transform")